//always ephemeral and always new session

import { greet } from "./main";

import {
  uploadChunk,
  updateFeed,
  downloadFeed,
  uploadSOC,
  downloadSOC,
} from "./main";

test("uploadChunk", async () => {
  let response = await uploadChunk();
  expect(response.reference).toBe(
    "ca6357a08e317d15ec560fef34e4c45f8f19f01c372aa70f1da72bfa7f1a4338"
  );
});

test("uploadSOC", async () => {
  let response = await uploadSOC();
  console.log(response);
  // expect(response.reference).toBe(
  //   "ca6357a08e317d15ec560fef34e4c45f8f19f01c372aa70f1da72bfa7f1a4338"
  // );
});

// test("uploadSOC", async () => {
//   let response = await uploadChunk();
//   expect(response.reference).toBe(
//     "ca6357a08e317d15ec560fef34e4c45f8f19f01c372aa70f1da72bfa7f1a4338"
//   );
// });

test("updateFeed", async () => {
  let response = await updateFeed();
  console.log(response);
  let response2 = await downloadFeed();
  console.log(response2);
});

test("downloadSOC", async () => {
  // let response = await uploadSOC();
  // console.log(response);

  let response2 = await downloadSOC();
  console.log(response2);
});

test("the data is peanut butter", () => {
  expect(1).toBe(1);
});

test("greeting", () => {
  expect(greet("Foo")).toBe("Hello Foo");
});

test("key pair E is generated by A", () => {
  // let A = new initiator();
  // generates 2 key pairs - message encryption key pair A and ephemeral key pair E
  // expect(A.ephemeral).toBe.aKey;
  // expect(A.encryption).toBe.aKey;
});

test("soc E0 is generated by A using E", () => {
  // A.initialise();
  // generates E0 and uploads to swarm
  // expect(A.handshake.chunks[0].toBe.aChunk);
  // expect(A.handshake.chunks[0].payload.toBe.pubkeyA);
});

test("key pair B is generated and E is restored", () => {
  // let B = new respondent(E);
  // generates message encryption key pair B and restores ephemeral key pair E
  // expect(B.ephemeral).toBe.keyE;
  // expect(B.encryption).toBe.aKey;
});

test("soc E0 is retrieved by B", () => {
  // B.initialise();
  // expect(B.handshake.chunks[0].toBe.aChunk);
  // expect(B.handshake.chunks[0].payload.toBe.pubkeyA);
  // expect(B.handshake.chunks[1].payload.toBe.pubkeyB);
  // expect(B.handshake.sharedSecret.toBe.sharedSecretAB);
});

test("soc E1 is generated by B using E", () => {
  // wait(()=>{
  // A.handshake.chunks[1].toBe.pubkeyA;
  // });
  // expect(A.handshake.sharedSecret.toBe.sharedSecretAB);
});

test("soc E1 is retrieved by A using E", () => {
  // wait(()=>{
  // A.handshake.chunks[1].toBe.pubkeyA;
  // });
  // expect(A.handshake.sharedSecret.toBe.sharedSecretAB);
});

test("soc A0 is generated by A using message encryption key A", () => {
  // expect(A.messages.sent[0]).toBe.aMessage;
  // expect(A.messages.sent[0].payload).toBe("initial");
  // expect(A.messages.sent[0].status).toBe("sent");
  // expect(A.messages.sent[0].time).toBe.aDateTime;
});

test("soc A0 is received by B and decrypted using S", () => {
  // expect(B.messages.received[0]).toBe.aMessage;
  // expect(B.messages.received[0].payload).toBe("initial");
  // expect(B.messages.received[0].status).toBe("sent");
  // expect(B.messages.received[0].time).toBe.aDateTime;
});

test("soc B0 is generated by B using message encryption key A", () => {
  // expect(A.messages.sent[0]).toBe.aMessage;
  // expect(A.messages.sent[0].payload).toBe("initial");
  // expect(A.messages.sent[0].status).toBe("sent");
  // expect(A.messages.sent[0].time).toBe.aDateTime;
});

test("soc B0 is received by A and decrypted using S", () => {
  // expect(A.messages.received[0]).toBe.aMessage;
  // expect(A.messages.received[0].payload).toBe("initial");
  // expect(A.messages.received[0].status).toBe("sent");
  // expect(A.messages.received[0].time).toBe.aDateTime;
});

test("soc B1 is generated by B using message encryption key A", () => {
  // expect(A.messages.sent[1]).toBe.aMessage;
  // expect(A.messages.sent[1].payload).toBe("hello world B");
  // expect(A.messages.sent[1].status).toBe("sent");
  // expect(A.messages.sent[1].time).toBe.aDateTime;
});

test("soc B1 is received by A and decrypted using S", () => {
  // expect(B.messages.received[1]).toBe.aMessage;
  // expect(B.messages.received[1].payload).toBe("hello world A");
  // expect(B.messages.received[1].status).toBe("sent");
  // expect(B.messages.received[1].time).toBe.aDateTime;
});
